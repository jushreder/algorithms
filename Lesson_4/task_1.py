'''
Проанализировать скорость и сложность одного любого алгоритма из разработанных
в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
● выбрать хорошую задачу, которую имеет смысл оценивать,
● написать 3 варианта кода (один у вас уже есть),
● проанализировать 3 варианта и выбрать оптимальный,
● результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N
вы проводили замеры),
● написать общий вывод: какой из трёх вариантов лучше и почему.
'''
import timeit
import cProfile
# вариант 1

# def func(a):
#     if a == 1:
#         return a
#     else:
#         return a + func(a - 1)
#
# a=func(10)

s='''
def func(a):
    if a == 1:
        return a
    else:
        return a + func(a - 1)
    
a=func(640)
'''

# print(timeit.timeit(s, number=1000))
# 0.0018562750000000044 = 10
# 0.003807622999999996 = 20
# 0.007669203000000006 = 40
# 0.015699987999999998 = 80
# 0.031239049000000005 = 160
# 0.06160847700000001 = 320
# 0.147443946 = 640
# cProfile.run('func(640)')
# 10/1    0.000    0.000    0.000    0.000 task_1_.py:16(func) =  10
# 20/1    0.000    0.000    0.000    0.000 task_1_.py:16(func) = 20
# 40/1    0.000    0.000    0.000    0.000 task_1_.py:16(func) = 40
# 80/1    0.000    0.000    0.000    0.000 task_1_.py:16(func) = 80
# 160/1    0.000    0.000    0.000    0.000 task_1_.py:16(func) = 160
# 320/1    0.000    0.000    0.000    0.000 task_1_.py:16(func) = 320
# 640/1    0.001    0.000    0.001    0.001 task_1_.py:16(func) = 649



# вариант 2

def func_2(a):
    func_d = {0: 0, 1: 1}
    def _func(a):
        if a in func_d:
            return func_d[a]
        func_d[a] = _func(a - 1) + a
        return func_d[a]

    return _func(a)

a=func_2(10)

b = '''
def func_2(a):
    func_d = {0: 0, 1: 1}
    def _func(a):
        if a in func_d:
            return func_d[a]
        func_d[a] = _func(a - 1) + a
        return func_d[a]

    return _func(a)

a=func_2(640)
'''

print(timeit.timeit(b, number=1000))

# 0.0018562750000000044   0.004860118999999996 = 10
# 0.003807622999999996    0.006820508000000003  = 20
# 0.007669203000000006    0.014491074000000007  = 40
# 0.015699987999999998    0.026411227999999995  = 80
# 0.031239049000000005    0.052541386999999995  = 160
# 0.06160847700000001     0.10661247200000001   = 320
# 0.147443946             0.24436216400000002   = 640

# cProfile.run('func_2(10)')
# 10/1    0.000    0.000    0.000    0.000 task_1_.py:57(_func) =10
# 20/1    0.000    0.000    0.000    0.000 task_1_.py:57(_func) =20
# 40/1    0.000    0.000    0.000    0.000 task_1_.py:57(_func) =40
# 80/1    0.000    0.000    0.000    0.000 task_1_.py:57(_func) =80
# 160/1    0.000    0.000    0.000    0.000 task_1_.py:57(_func) =160
# 320/1    0.000    0.000    0.000    0.000 task_1_.py:57(_func) =320
# 640/1    0.001    0.000    0.001    0.001 task_1_.py:57(_func) = 640



# вариант 3
def func_3(a):
    sum_=0
    for i in  range(1,a+1):
        sum_+=i
    return sum_

a=func_2(10)

c = '''
def func_3(a):
    sum_=0
    for i in  range(1,a+1):
        sum_+=i
    return sum_

a=func_3(2560)
'''

# print(timeit.timeit(c, number=1000))

#   0.0011874090000000004 = 10
#   0.002045825000000001  = 20
#   0.003758024999999998  = 40
#   0.005645154999999999  = 80
#   0.01695249           = 160
#   0.028289543          = 320
#   0.045234286          = 640
#   0.100292711999999    = 1280
#   0.210875588          = 2560

# cProfile.run('func_3(1000000)')
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 10
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 20
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 40
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 80
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 160
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 320
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 640
     # 1    0.000    0.000    0.000    0.000 task_1_.py:97(func_3) = 1280
     # 1    0.009    0.009    0.009    0.009 task_1_.py:97(func_3) = 100000
     # 1    0.079    0.079    0.079    0.079 task_1_.py:97(func_3) = 1000000
'''
Вывод: фунция с циклом показывает линейную зависимость и работает
быстрее рекурсии примерно в 3 раза. Рекурсия на больших значениях 
переполняет стек.
'''
